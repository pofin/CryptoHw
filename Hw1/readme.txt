HW One: Nolan Pofi

	A quick synopsis of my program is that it asks for the user to enter an 8-bit long plaintext string in binary along with a 10-bit long key. The program then runs the toy DES outlined in the slides to encrypt the 8-bit long string and it prints it out to show the encryption. The program then decrypts the encrypted string and outputs it to show it matches the original input. I wanted to have the input be anything and the program converts it to binary and then encrypts it but I had trouble getting it to work and opted to show that the DES does do what it is designed to do. I also wanted to have the program use sockets and TCP to send out the encryption and have the decryption be done elsewhere, however I had trouble getting the sockets working I saw on piazza that it didn’t have to do this so I ended up just calling the decryption in the same program. The encryption/decryption works by calling a function called DES that takes three inputs plaintext, key, and an integer which determines whether an encryption or decryption is taking place. It starts by running the initial permutation on the plaintext rearranging the bits with the placements going left to right as in the left-most bit is in place one. The new changed string is then split into a left and right halves. At this point it calls another function that will take the given key and output K1 and K2 used for round one and round two of the actual encryption. This function begins by running a permutation on the 10-bit key. It then splits the permutated key in half and runs a left circular shift of one bit on each half. The modified two halves are then combined and permutated into an 8-bit string which is K1. The two halves go through another circular left shift of one bit and permutated again to get K2. It returns these two values and they are assigned to variables in the DES function. Round one of the DES then begins by setting the left side of used in round two to the right side of round one and then xoring the left side of round one and the product of the F(R,K1) and setting that equal to the right side of round two. This is repeated for round two and finally the two halves are put back together and undergo the inverse of the initial permutation and the result is the encryption. To decrypt the DES uses K2 in round one and K1 in round two. While the rounds could easily have been done in a loop I chose to keep them separated because there are only two rounds and it makes it clear what is happening. The F function expands the 4 bits passed to it into 8 and then xors it with the key passed to it. The result is then split into a left and right half. The left half then goes through the Sbox0 with the outer most bits combining to get the row and the innermost to get the column. The right half goes through the same on Sbox1. The output of both are then combined together and permutated another time before being returned for use in the DES round.   

